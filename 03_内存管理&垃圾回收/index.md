## 变量环境&环境记录

**早期 es 规范**

之前讲到的 VO/GO 都是 ES6 以前的规范

每一个执行上下文都会被**关联**到一个变量对象(variable Object)VO 中 在源代码中的 变量和函数声明 会被作为属性添加到 VO 中

对于函数来说 函数内部的参数 内部声明的变量也会被添加到 VO 中

GEC(global excution context)全局执行上下文: 执行全局代码
FEC(function excution context)函数执行上下文: 执行函数代码

**现代 es 规范**

每一个执行上下文关联到一个变量环境(VariableEnvironment)中 在执行代码中变量和函数的声明会作为**环境记录**(Environment Record) 添加到变量环境中

对于函数而言参数也会被作为环境记录添加到变量环境中

**将变量对象(VO)名词改为变量环境(VE) 环境属性改为环境记录**

VE 跟 js 引擎实现有关 VE 可以不再是一个对象 而是一个 map(key:value)

## 内存管理

代码一般是磁盘加载到内存里之后由 CPU 去执行 在执行期间需要不断开辟内存

不管怎样的编程语言 在代码执行的过程中都是需要给它分配到内存中 不同的是某些编程语言需要我们自己手动的管理内存 某些编程语言会可以自动帮助我们管理内存

不管以什么样方式来管理内存 内存的管理都会有如下生命周期:

1. 分配申请你需要的内存 (申请)
2. 使用分配的内存 (存放一些东西 比如对象)
3. 不需要使用时 对齐进行释放

不同编程语言对于上述 3 步中 13 两步可能会有些不同

手动管理内存: C C++ Rust 都是需要手动来管理内存的申请和释放(malloc、free)函数
自动管理内存 java js py

## js 内存管理

首先 js 在我们定义变量时会为我们自动分配内存

当时内存分配方式稍显差异

- 对应基本数据类型内存的分配会在执行时 直接在栈空间积习难改分配
- 对应复杂数据类型内存的分配会在堆内存中开拍一块空间 并且将这块空间的指针返回值变量引用

## js 垃圾回收

因为内存大小是有限的 所以当内存不再需要时 我们需要对齐进行释放 以便腾出更多的内存空间

在手动管理内存的语言中有两大弊端 影响逻辑编码的效率 随时都可能发生的内存泄露

所以大部分现代编程语言都是有自己的垃圾回收机制的 js 也不例外

垃圾回收的英文是 Garbage Collection 简称 GC

对于那些不再使用的对象 我们都称之为垃圾 垃圾就必须要被回收 以释放更多的内存空间

而我们的语言运行环境 例如 V8 有自己内置 GC

但是这也引发了另外一个问题? **GC 怎么知道哪些对象不再使用了呢?**

## GC 算法

**引用技数**

原理: 当一个对象有一个引用指向它时 那么这个对象的引用就+1 当一个对象的引用为 0 时 这个对象就可以被销毁掉

缺点: 循环引用 隔这隔这呢

```js
// 这种情况下怎么都不会 回收掉
obj1 = { xxx: obj2 };
obj2 = { xxx: obj1 };
```

**标记清楚**

这个算法是设置一个根对象(root object) 垃圾回收器会定期从这个根部开始 找所有根开始有引用到的对象 对于那些没有引用到的对象 就认为是不可用的对象

这个算法可以很好的解决循环应用的缺点

js 引擎比较广泛的采用就是标记清楚算法 当然类似于 V8 引擎为了进行更好的优化 它在算法的实现细节上也会结合一些其他算法
