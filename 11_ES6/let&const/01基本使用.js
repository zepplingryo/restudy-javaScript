/**
 * **let 与 const**
 * let 创建的是变量 只不过他的指针指向可以随意更改
 * const 创建的是变量 他的指针指向一旦确定就不能修改 [看起来像但不是常量]
 * const 创建的变量值是不允许被修改的
 * 
 * **let 与 var**
 * 1. let 不存在变量提升
 * 在代码执行阶段 在 let 定义一个变量之前就使用它 浏览器会先看下方的代码中有没有 let 声明该变量
 * 若声明了则会报错 不能在 let 声明之前使用该变量
 * 否则报错 未定义
 * 
 * 2. let 不允许重复声明
 * 在同一个上下文中不允许使用 let 重复声明同一个变量 只要这个变量已经存在了 且 检测报错发生在词法解析(AST 词法解析树)阶段 而不是在代码执行阶段 (词法解析 ast 词法解析树: 把代码拆分成对应的字符 并且识别为浏览器可以解析点对象) (此阶段包含 作用域链的形成 形参赋值 this 指向 变量提升 词法解析结束后才会进行代码执行)
 * 
 * 3. 暂时性死区问题
 * 浏览器 bug 检测一个未被声明点变量 不会报错 结果是 undfind 用 let 可以解决

- let:
  允许你声明一个作用域被限制在块级中的变量 语句或者表达式 (自带块级作用域)
  let 绑定不受变量提升的约束 意味着 let 声明不会被提升到当前
  该变量处于从块开始到初始化处理的`TDZ`暂时性死区

- var:
  变量声明的作用域限制在其声明位置的上下文 而非声明变量总是全局的
  由于变量声明(以及其他声明)总是在任意代码执行之前处理的 所以在代码中的任意位置声明变量总是等效于在代码开头声明

- const:
  **声明创建一个值的只读引用(即指针)**
  基本数据当值发生改变时 那么其对应的指针也将发生改变 故造成 const 声明基本数据类型时
  再将其值改变时 将会造成报错 例如 const a = 3; a = 5 时将会报错
  但是如果是复合类型时 如果只改变复合类型的其中某个 Value 项时 将还是正常使用 **这里可以提一下引用类型和基本类型的区别**
 */
