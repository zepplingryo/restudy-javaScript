/**
 * 探讨一下如下代码如何在内存中执行的
 *
 * 我们都知道在变量查找时 就是以作用域链查找机制进行查找(scope chain) 就是当前 VO + parent scope
 *
 * 这个就是闭包 而且是严格意义上的闭包
 *
 * 但是回过头想这个问题 为什么我定义函数foo内部代码执行完了却没有销毁呢?
 *
 * 也正是因为foo内部变量name没有被销毁 才能在bar函数中打印他
 *
 * 这就是闭包的特点 让我们本该销毁的变量 却保存了起来没有被销毁 而没有销毁时候 在这里调用bar时依然能访问到AO里面的东西
 *
 * 而当前形成的闭包就是 bar函数本身以及其外部可以访问到的变量
 *
 * 这也是维基百科中 闭包跟函数最大的区别在于 当捕捉闭包的时候 它的自由变量会在捕捉时被确定 这样即使脱离了不做时的上下文 也能照常运行
 *
 */

function foo() {
  var name = "foo";
  function bar() {
    console.log(name);
  }

  return bar;
}

var fn = foo();

fn();
